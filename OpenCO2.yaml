esphome:
  name: openco2
  on_boot:
    priority: -100
    then:
      - script.execute: set_state_empty
  on_shutdown:
    priority: 700
    then:
      - light.turn_off: status_led  # ðŸ’¡ FIX: Send software OFF command
      - delay: 50ms                   # Wait briefly
      - switch.turn_off: LED_power    # Then cut hardware power
      - switch.turn_off: EPD_power

esp32:
  board: lolin_s2_mini
  variant: esp32s2
  framework:
    type: esp-idf

wifi:
  ssid: !secret wifi_ssid # Use your own secrets variable
  password: !secret wifi_password # Use your own secrets variable
  fast_connect: true
  power_save_mode: HIGH
  ap:
    ssid: "ESP32_openCO2"
    password: !secret hotspot_password # Use your own secrets variable

web_server:
  port: 80
  log: false
  version: 3
  
captive_portal:
api:
ota:
  - platform: esphome
logger:
  level: INFO

deep_sleep:
  id: deep_sleep_1
  # Wakeup on button press
  wakeup_pin:
    number: GPIO0
    inverted: true
    mode:
      input: true
      pullup: true

switch:
  - platform: gpio
    id: LED_power
    name: LED power
    pin: GPIO9
    inverted: true
    internal: true
  # Add LED enable/disable switch
  - platform: template
    name: "LED Enable"
    id: led_enable
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - switch.turn_on: LED_power # Turn on hardware power
      # When turning on, rely on the 1s interval to set color/brightness
    
    on_turn_off: 
      - light.turn_off: status_led # ðŸ’¡ FIX: Send software OFF command first
      - delay: 50ms                 # Give the software command time to execute
      - switch.turn_off: LED_power  # Then cut hardware power
  - platform: gpio
    pin: 45
    id: EPD_power
    name: EPD power
    inverted: false
    restore_mode: ALWAYS_ON
    internal: true

time:
  - platform: sntp
    id: sntp_time
    timezone: Asia/Kolkata

light:
  - platform: spi_led_strip
    id: status_led
    name: "Status LED"
    spi_id: led_spi
    num_leds: 1
    data_rate: 5MHz
    internal: true
    default_transition_length: 0s
    color_correct: [25%, 25%, 25%]
    #brightness: 

interval:
  - interval: 1s
    then:
      # Execute LED update script continuously only if USB is connected
      - if:
          condition:
            sensor.in_range:
              id: usb_adc
              above: 1.0
          then:
            - script.execute: update_led_color

text_sensor:
  - platform: template
    name: Open CO2 state
    id: system_state
    internal: true

i2c:
  - sda: GPIO33
    scl: GPIO34
    scan: false
    id: bus_a

spi:
  - clk_pin: 41
    mosi_pin: 21
    id: disp_spi
  # Second SPI bus for LED (software SPI)
  - clk_pin: GPIO39
    mosi_pin: GPIO40
    id: led_spi

sensor:
  - platform: scd4x
    id: my_scd40
    measurement_mode: low_power_periodic
    update_interval: 1min
    co2:
      name: "ppm CO2"
      id: scd40_ppm
    temperature:
      name: "SDC40 Temperature"
      id: scd40_t
    humidity:
      name: "SDC40 Humidity"
      id: scd40_rh
      on_value:
        if:
          condition:
            sensor.in_range:
              id: usb_adc
              below: 1.0  # Battery mode
          then:
            - delay: 3s
            - component.update: EPD
            - delay: 5s  # Let display finish updating
            - deep_sleep.enter:
                id: deep_sleep_1
                sleep_duration: 15min  # Sleep for 5 minutes on battery
          else:
            # On USB power - just update display, don't sleep
            - delay: 3s
            - component.update: EPD

  - platform: adc
    pin: 5
    name: "OpenCO2 BattV"
    attenuation: 11db
    id: battV
    update_interval: 20s
    filters:
      - multiply: 2
    on_value_range:
      - below: 3.35  # Low battery shutdown
        then:
          - script.execute: set_state_discharged
          - component.update: EPD
          - delay: 6s
          - script.execute: low_battery_shutdown

  - platform: adc
    pin: 4
    attenuation: 11db
    name: "USB Present"
    id: usb_adc
    update_interval: 15s
    internal: true
    on_value_range:
      - above: 1.0  # USB connected
        then:
          - deep_sleep.prevent: deep_sleep_1
      - below: 0.8  # USB disconnected
        then:
          - deep_sleep.allow: deep_sleep_1

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_strength
    update_interval: 60s
    internal: true

script:
  - id: set_state_empty
    then:
      lambda: |-
        if(id(usb_adc).state > 1.0)
          id(system_state).publish_state("___ Open CO2 USB ___");
        else
          id(system_state).publish_state("___ Open CO2 ___");
  
  - id: set_state_discharged
    then:
      lambda: |-
        id(system_state).publish_state("DISCHARGED!!!");
  
  - id: low_battery_shutdown
    then:
      lambda: |-
        if(id(usb_adc).state < 1.0) {
          esp_deep_sleep_start();  // Never wake up - only via reset
        }
  - id: update_led_color
    then:
      - lambda: |-
          // 1. Check conditions to DISABLE/POWER OFF LED
          if (id(usb_adc).state < 1.0 || !id(led_enable).state) {
            // FIX: The on_shutdown and on_turn_off handlers manage the physical power switch.
            // This script should only send the software OFF command here.
            auto call = id(status_led).turn_off();
            call.perform();
            return;
          }

          // 2. Logic for smooth color transition (from Arduino sketch)
          // Ensure hardware power is ON (controlled by 'LED Enable' switch)
          // We rely on the 'LED Enable' switch's on_turn_on action to power this ON. 
          
          int co2 = (int)id(scd40_ppm).state;
          int red = 0, green = 0, blue = 0;
          float brightness_pct = 1.0; // Assuming max brightness if no number component used
          
          // ... (Color and math logic remains the same)
          if (co2 > 2000) {
            red = 216; green = 2; blue = 131;
          } else {
            red = std::round(std::pow((co2 - 400), 2) / 10000);
            green = std::round(-std::pow((co2 - 400), 2) / 4500 + 255);
            
            red = std::max(0, std::min(255, red));
            green = std::max(0, std::min(255, green));
          }
          
          auto call = id(status_led).turn_on();
          call.set_rgb((float)red/255.0, (float)green/255.0, (float)blue/255.0);
          call.set_brightness(brightness_pct);
          call.perform();
          
display:
  - platform: waveshare_epaper
    spi_id: disp_spi
    id: EPD
    rotation: 270Â°
    cs_pin: 42
    dc_pin: 8
    busy_pin: 6
    reset_pin: 7
    reset_duration: 2ms
    model: 1.54inv2
    update_interval: never
    full_update_every: 1
    lambda: |-
      // Top: Temperature (left) and Humidity (right)
      // Temperature whole number
      it.printf(1, 5, id(font_temp_hum), TextAlign::TOP_LEFT, "%.0f", id(scd40_t).state);
      it.printf(65, 5, id(font_degree), TextAlign::TOP_LEFT, "Â°C");
      
      // Temperature decimal on second line
      int temp_decimal = ((int)(id(scd40_t).state * 10)) % 10;
      it.printf(65, 27, id(font_degree), TextAlign::TOP_LEFT, " .%d", temp_decimal);
      
      // Humidity
      it.printf(124, 5, id(font_temp_hum), TextAlign::TOP_LEFT, "%.0f", id(scd40_rh).state);
      it.printf(184, 5, id(font_degree), TextAlign::TOP_LEFT, "%%");
      
      // Center: Large CO2 - matching Arduino positioning exactly
      int co2_value = (int)id(scd40_ppm).state;
      if (co2_value > 9999) {
        it.printf(27, 78, id(font_co2_medium), TextAlign::TOP_LEFT, "%d", co2_value);
      } else if (co2_value < 1000) {
        // 3 digits
        it.printf(40, 65, id(font_co2_xlarge), TextAlign::TOP_LEFT, "%.0f", id(scd40_ppm).state);
      } else {
        // 4 digits
        it.printf(35, 65, id(font_co2_xlarge), TextAlign::TOP_LEFT, "%.0f", id(scd40_ppm).state);
      }
      
      // Bottom: "ppm" label
      it.printf(144, 130, id(font_ppm), TextAlign::TOP_LEFT, "ppm");
      
      // Bottom left: WiFi/Time on USB, Battery on battery
      if (id(usb_adc).state > 1.0) {
        auto time = id(sntp_time).now();
        if (time.is_valid()) {
          it.strftime(5, 170, id(font_degree), TextAlign::TOP_LEFT, "%H:%M", time);
        }
        if (id(wifi_signal_strength).has_state()) {
          // Calculate signal level (1-4) from dBm for icon selection
          int rssi = (int)id(wifi_signal_strength).state;
          int strength;
          if (rssi >= -67) {
            strength = 4; // Excellent
          } else if (rssi >= -70) {
            strength = 3; // Good
          } else if (rssi >= -80) {
            strength = 2; // Fair
          } else if (rssi >= -90) {
            strength = 1; // Weak
          } else {
            strength = 0; // Very Weak
          }

          // C++ Ternary operators to select the correct Unicode icon glyph
          const char* wifi_icon = 
              (strength == 4) ? "ó°¤¨" :  // Strength 4
              (strength == 3) ? "ó°¤¥" :  // Strength 3
              (strength == 2) ? "ó°¤¢" :  // Strength 2
              (strength == 1) ? "ó°¤Ÿ" :  // Strength 1
                                "ó°¤®";   // Strength 0 (outline/off)
                  
          // Display the icon and dBm value
          it.printf(75, 170, id(font_degree), TextAlign::TOP_LEFT, "%s %.0fdBm", wifi_icon, id(wifi_signal_strength).state);

        }
      } else {
        float voltage = id(battV).state;
        int battery_pct = 100;
        if (voltage < 3.2) battery_pct = 0;
        else if (voltage < 3.6) battery_pct = (voltage - 3.2) / 0.4 * 50;
        else if (voltage < 4.2) battery_pct = 50 + (voltage - 3.6) / 0.6 * 50;
        
        it.rectangle(1, 153, 91, 35);
        it.rectangle(92, 161, 5, 19);
        it.printf(20, 159, id(font_degree), TextAlign::TOP_LEFT, "%d%%", battery_pct);
      }

font:
  # Temperature/Humidity - BebasNeue 30pt (Arduino font2)
  - file: 'fonts/bahn.ttf'
    id: font_temp_hum
    size: 60
    glyphs: [
      0123456789,
      Â°, ., C, F, m, p,
      "\u0020",
      "\u0025"
      ]
    
  # Degree symbols and small text - Arial 24pt (Arduino sml)
  - file: 'fonts/bahn.ttf'
    id: font_degree
    size: 28
    bpp: 4
    extras:
      - file: "fonts/materialdesignicons-webfont.ttf"
        glyphs: [
          "\U000F091F", # mdi-heart
          "\U000F0922", # mdi-wifi-strength-2
          "\U000F0925", # mdi-wifi-strength-3
          "\U000F0928" # mdi-wifi-strength-4
          ]
    
  # CO2 extra large - Arial 65pt (Arduino font3/big)
  - file: 'fonts/bahn.ttf'
    id: font_co2_xlarge
    size: 80
    
  # CO2 medium for >9999 - BebasNeue 45pt (Arduino mid)
  - file: 'fonts/bahn.ttf'
    id: font_co2_medium
    size: 45
    
  # "ppm" label - Arial 24pt
  - file: 'fonts/bahn.ttf'
    id: font_ppm
    size: 22
